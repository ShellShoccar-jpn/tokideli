# PTWコマンドの役割について

このコマンドは`stdbuf`コマンドの代替用です。なぜ、`stdbuf`があるのにわざわざ`ptw`が必要なのかについて記します。

(English version is [here](ptw.info.en.md))

## `stdbuf`コマンドの制約

まずは下記のワンライナーを実行してみてください。

```sh:
# (A) macOSユーザー限定
$ while sleep 1; do date; done | stdbuf -o L tr 1 1 | cat

# (B) Python3を使える環境限定
$ while sleep 1; do date; done | stdbuf -o L python3 -c 'import sys; [print(l,end="") for l in sys.stdin]' | cat

# (C) Perlを使える環境限定
$ while sleep 1; do date; done | stdbuf -o L perl -e 'while(<>){print}' | cat
```

`stdbuf`コマンドが正しく作用していれば、どれも画面上に時報が1秒毎に表示されるはずです。しかし実際にはそうはなりません。理由は、`stdbuf`コマンドが、デフォルトではフルバッファリングになっているモードの変更に失敗するためです。`stdbuf`で指定されているコマンドはどれもバッファリングモード変更要求を無視し、バッファが一杯になるまでバッファリングをします。その結果、時報は時間通りには表示されないのです。

### 問題の発生原因

`stdbuf`がどのように作用しているかを知ることで、この問題を理解できるようになります。

`stdbuf`は、"LD_PRELOAD"という機構を用いて対象コマンドのバッファリングモードを変更しています。ほどんどのUNIXコマンドは、ファイルサイズの肥大化を防ぐためにダイナミックリンクでビルドされているのですが、ということはこちらから新たなライブラリーを読み込ませることができれば、そのコマンドの動作を変更することができるというわけです。

"LD_PRELOAD"はまさにそれをするための機構であり、ビルド済みコマンドの動作を変更するための有効な方法の一つです。`stdbuf`は"LD_PRELOAD"機構を用い、起動中のターゲットコマンドにバッファリングモード変更用のプログラムを実行させているのです。

しかしながらこの仕組みゆえに、スタティックリンクでビルドされているコマンドには効果がありません。macOS上`tr`コマンドはこのようなコマンドの一種です。幸い、`tr`コマンドの場合は、GNUが提供している`gtr`というコマンドを使うことでこの問題を回避できますが、GNUプロジェクトが常にこのような代替コマンドを用意しているとは限りません。

一方、(B)と(C)の場合は少し理由が異なります。PythonもPerlもバッファリングモード管理のルーチンを独自に持っており、`stdbuf`が事前にバッファリングモードを変更していたとしても、これら言語コマンドが起動した時にモードを上書きして元に戻してしまっていることが原因です。この場合の回避策は、各言語のスクリプト内にモード変更用のステートメントを書くということになってしまいます。

## 解決のためのアイデア

先程打ち込んだワンライナーを振り返ってみると、次のようにして`tr`、`python`、`perl`の各コマンドの後ろの`cat`コマンドを消し、それぞれがワンライナーの末端にあるようにすると、バッファリングモード問題が解消します。

```sh:
# (A) macOSユーザー限定
$ while sleep 1; do date; done | tr 1 1

# (B) Python3を使える環境限定
$ while sleep 1; do date; done | python3 -c 'import sys; [print(l,end="") for l in sys.stdin]'

# (C) Perlを使える環境限定
$ while sleep 1; do date; done | perl -e 'while(<>){print}'
```

これがバッファリング問題解消のために重要なカギです。

実はC言語に仕様によれば、あるプログラムの標準出力が（パイプラインでもファイルでもなく）「端末」に接続されている場合、そのプログラムのバッファリングモードは完全バッファリングではなく行バッファリングにするようにと記されています。従って上記の場合、まず`tr`コマンドについては、それが端末に繋がるようになったため、完全バッファリングではなくなって問題が解消したのです。なお、(B)と(C)については、PythonとPerlがそれぞれ独自にバッファリング管理をしているからだと述べましたが、これらもC言語の仕様に従い、接続先が端末かどうかという確認をしてバッファリングモードを変更するという処理を、それぞれ独自に行っています。

### 疑似端末（PTY）の活用

`ptw`コマンドとはラッパーコマンドであり、ラッピングしている対象コマンドに対して、自分の標準出力の接続先は端末であると思い込ませる働きをします。例えば`ptw TARGET_COMMAND ARG1 ARG2 ...`というように実行された場合、疑似端末（PTY）を活用し、具体的には次のような手順で動作します。

1. 対象コマンドに代わって`ptw`が起動する。
1. `ptw`は疑似端末を作る。
1. `ptw`はfork()で子プロセスを作る。すると疑似端末が親子で共有できるようになる。
1. 子プロセス側は自分の標準出力を疑似端末のディスクリプタ（接続口）に繋ぎ変える。
1. 子プロセス側はexec()して`TARGET_COMMAND ARG1 ARG ...`に成り代わる。すると、TARGET_COMMAND は自分は端末に繋がれているものと判断してバッファリングモード変え、かつ本物の標準出力ではなく、親プロセスが用意した疑似端末のディスクリプタにデータを書き出すことになる。
1. 親プロセス側は、疑似端末のディスクリプタ（接続口）を監視する無限ループに入る。もしそこからデータが到来していれば、そのまま本物の標準出力へ書き出す。

したがって、ワンライナーを次のように書き換えてやれば、バッファリング問題は解消するというわけです。

```sh:
# (A) macOSユーザー限定
$ while sleep 1; do date; done | ptw tr 1 1 | cat

# (B) Python3を使える環境限定
$ while sleep 1; do date; done | ptw python3 -c 'import sys; [print(l,end="") for l in sys.stdin]' | cat

# (C) Perlを使える環境限定
$ while sleep 1; do date; done | ptw perl perl -e 'while(<>){print}' | cat
```

よって、**`ptw`コマンドは`stdbuf -o L`の強化版と見なすことができます。**

## `ptw`コマンドの使い方

`ptw`の使用方法はとても簡単です。対象コマンドの手前にただ"ptw"という一単語を挿入するだけです。もし既に`stdbuf -o L`という記述を利用していたのであれば、それらをすべて"ptw"に置換してください。以上です。

ただ、"ptw"の単語はワンライナーの最後のコマンドに対しては書く必要がありません。もし書いたとしてもその場合、`ptw`は普通に対象コマンドを起動するだけです。

以上を踏まえると、`ptw`の使い方は次の通りです。

```sh:
ptw CMD1 arg1a arg1b ... | ptw CMD2 arg2a arg2b ... | ... | CMD9 arg9a arg9b ...
```

## `ptw`も万能ではない

`ptw`が`stdbuf`より強力であることは間違い無いのですが、`ptw`をもってしてもバッファリングモードを変更できないコマンドもいくつかあります。

### `mawk`

`mawk`はAWKの実装の一つであり、Raspberry PiやUbuntuが標準で利用するAWKとして使われている場合があります。そして、この`mawk`もまたバッファリングモードを独自に管理しているコマンドの一つであり、バッファリングモードを外部から事前に設定しても起動後に書き換えてしまいます。

`mawk`でフルバッファリングモードを止めさせるには`-W interactive`というオプションを使うしかありません。そこで、お使いのAWKがこの`mawk`である可能性がある場合、各AWKに対して`ptw`を使う代わりに、次のような記述をシェルスクリプトの冒頭に書いてください。

```sh:
# （シェルスクリプトの冒頭で指定する）
case $(awk -W interactive 'BEGIN{print}' 2>&1 >/dev/null) in
  '') alias awk='awk -W interactive';;
   *) alias awk='ptw awk'           ;;
esac
```

### PerlやPythonの中で、バッファリングモード指定をする

この場合もやはり、それらのコマンド起動後にバッファリングモードが上書きされてしまいます。したがって、それらのスクリプトの中でバッファリングモードを指定しているステートメントを取り除く以外に回避方法はありません。

### バッファリングモードを上書きするその他のコマンド

同様の理由で、そのようなコマンドを使う場合もそれらのバッファリングモードを指定している箇所を何らかの方法で取り除くしかありません。

### シェルスクリプトで書かれているコマンド

シェルスクリプト製コマンドにおいて、そのシェルスクリプトのバッファリングモードを決めているのはそのシェルスクリプト自身ではなく、中で呼び出しているコマンドです。したがってこの場合は、中に記述している各コマンドに直接`ptw`を適用してください。

## 副作用

コマンドによっては、自分が端末に繋がれているかどうかで出力内容を変化させるものがあります。`ptw`でラッピングされたコマンドは自分が端末に繋がれていると思い込むため、意図しない出力が得られる場合があります。

例えば`ls`コマンドはそのようなコマンドの一つで、次の例では`ptw`でラップするかしないかで結果が変わります。

```sh:
$ ls | cat
$ ptw ls | cat
```

ptwを付けると画面幅に応じてファイル文字列を横に並べようとしますが、付けない場合は1ファイル1行で出力しようとするからです。ptwを付けている場合でも1ファイル1行にしたい場合は`-1`オプションを使ってください。

```sh:
$ ptw ls -1 | cat
```

その他、一部の`grep`コマンドは端末に接続されていると見なすと色付けするものがあり、`ptw`コマンドでラッピングすると色付けが行われてしまうことがあります。

```sh:
$ seq 1 100 | ptw grep --color=auto 1 | cat
```

ただし、通常、`--color=auto`のようなオプションに関しては実際に深刻な影響を受けることはほとんどありません。 これらのオプションは、通常シェルのエイリアスによって定義されており、`ptw`のような外部コマンドからはエイリアス定義を認識できないためです。
